using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            /* Модуль 7.ООП.Продолжение
              
            *************************
            * 7.1. Наследование
            *************************
             
            Наследование — это возможность объекта являться потомком другого объекта, перенимая его характерные свойства и методы.
            При наследовании рассматривают 2 класса: родитель и наследник. Cтруктуры не могут наследоваться друг от друга или от других классов/

            Родительский или базовый класс — это класс, от которого происходит наследование и чьи поля, свойства и методы перенимает наследник.
            Для использования механизма наследования в C# достаточно при объявлении класса указать базовый класс через двоеточие после названия 
            объявляемого класса-наследника:

                class BaseClass
                {

                }

                class InheritedClass : BaseClass
                {
    
                }

            В данном примере InheritedClass является наследником, а BaseClass — базовым классом.
            Рассмотрим пример из видео, для этого возьмем уже знакомый по прошлому модулю класс Car и унаследуемся от него, создав класс HybridCar:

        class Car
        {
            public double Fuel;

            public int Mileage;

            public Car()
            {
                Fuel = 50;
                Mileage = 0;
            }

            public void Move()
            {
                // Move a kilometer
                Mileage++;
                Fuel -= 0.5;
            }

            public void FillTheCar()
            {
                Fuel = 50;
            }
        }

        enum FuelType
        {
            Gas = 0,
            Electricity
        }

        class HybridCar : Car
        {
            public FuelType FuelType;

            public void ChangeFuelType(FuelType type)
            {
                FuelType = type;
            }
        }

            Таким образом, мы создали класс-наследник, который имеет собственное поле FuelType и унаследованные поля Fuel, Mileage, а также методы 
            ChangeFuelType, Move, FillTheCar.

            Наследование реализует отношение is-a (является). Объект класса HybridCar также является объектом класса Car, что позволяет использовать
            переменную типа Car:

                    Car car = new HybridCar();
                    car.Move();

            По умолчанию все классы наследуются от базового класса object (System.Object), даже если мы явным образом не устанавливаем наследование. 
            Поэтому классы Car и HybridCar, кроме своих собственных методов, также будут иметь и методы класса Object: 
            ToString(), Equals(), GetHashCode() и GetType():

            Все классы по умолчанию могут наследоваться. Но у этого механизма есть ряд ограничений:

                    Не поддерживается множественное наследование классов. То есть класс может наследоваться только от одного класса.
                    
                    Тип доступа к классу-наследнику должен быть таким же, как и у базового класса, или более строгим. То есть нельзя 
                    поставить наследнику модификатор public, если базовый класс имеет модификатор internal.

             Если класс имеет модификатор sealed, то от этого класса нельзя наследовать и создавать производные классы. Например, следующий класс не допускает создание наследников:
            
                    sealed class Admin
                    {
                    }  

            --------------------------------------
            Доступ к элементам базового класса
            --------------------------------------

            Как вы можете помнить, модификаторы доступа определяют видимость поля, свойства или метода. Рассмотрим на следующем примере, 
            как это работает с наследованием:

    class BaseClass
    {
        public string Name;
        protected string Description;
        private int value;
    }

    class InheritedClass : BaseClass
    {

    }

            В данном примере BaseClass имеет 3 поля с разными модификаторами: public, protected и private. Таким образом, класс 
            InheritedClass будет иметь доступ к 2 из них — Name и Description, причём Name так и останется открытым, доступ к нему 
            можно будет получить вне класса, а доступ к Description будет только внутри класса InheritedClass и внутри его наследников.

            Помимо данных модификаторов существуют еще 3. Попробуйте с помощью полученных знаний из прошлого модуля верно ответить на несколько вопросов.

            Задание 7.1.1
            Для элементов класса с модификатором internal класс-наследник:

                Будет иметь доступ, если наследник и базовый классы находятся в одной сборке

            Задание 7.1.2
            Для элементов класса с модификатором private protected класс-наследник:

                Будет иметь доступ, если наследник и базовый классы находятся в одной сборке

            Задание 7.1.3
            Для элементов класса с модификатором protected internal класс-наследник:

                Будет иметь доступ, даже если наследник и базовый классы находятся в разных сборках

            Задание 7.1.4
            Для следующего класса Employee создайте 2 наследника: ProjectManager и Developer.

        class Employee
        {
            public string Name;
            public int Age;
            public int Salary;
        }

            Класс ProjectManager должен содержать строковое поле ProjectName, а класс Developer — строковое поле ProgrammingLanguage.

                 class ProjectManager : Employee
                 {
                    public string ProjectName;
                 }

                 class Developer : Employee
                 {
                     private string ProgrammingLanguage;
                 }

            Задание 7.1.5 
            Для следующего списка объектов создайте схему классов (объявите нужные классы и установите связи между ними):

                Apple (яблоко);
                Banana (банан);
                Pear (груша);
                Potato (картофель);
                Carrot (морковь).

                class Food { }

                class Fruit : Food { }

                class Vegetable : Food { }

                class Apple : Fruit { }

                class Banana : Fruit { }

                class Pear : Fruit { }

                class Potato : Vegetable { }

                class Carrot : Vegetable { }

            --------------------------------------
            Ключевые слова this и base
            --------------------------------------

            Ключевое слово this представляет ссылку на текущий экземпляр класса. Оно может служить для указания на элементы класса в случае 
            совпадения имен параметров методов/конструктора с наименованием полей класса, например:

class Obj
{
	private string name;
	private string description;

	public Obj(string name, string description)
	{
		this.name = name;
		this.description = description;
	}
}

            Конструктор класса Obj принимает параметры name и description, когда класс уже содержит поля с такими именами. В области видимости
            конструктора параметры имеют больший приоритет, поэтому при обращении к переменной "name" компилятор будет обращаться к параметру. 
            При указании же this компилятор осознает, что обращение происходит к конкретному полю name экземпляра данного класса, для которого 
            и выполняется этот конструктор.

            Если бы мы просто написали name = name;, компилятор не понял бы нас, и было бы выдано предупреждение, что данная строка не имеет смысла:

            Также this позволяет обращаться к другому конструктору данного класса для его вызова перед указанным конструктором. Для этого достаточно 
            после объявления конструктора и до фигурных скобок указать двоеточие и вызвать нужный конструктор через this(), по необходимости передавая ему параметры.

            Данный синтаксис неслучайно похож на наследование: конструктор, к которому мы обращаемся выполнится раньше, чем код, который идет в вызываемом
            конструкторе, что можно считать как наследование функциональности конструктора.

class Obj
{
	private string name;
	private string description;

	public Obj()
	{
		Console.WriteLine("Вызван конструктор без параметров");
	}

	public Obj(string name, string description) : this()
	{
		this.name = name;
		this.description = description;
	}
}

            В данный пример мы добавили конструктор без параметров, который лишь выводит сообщение в консоль, и указали его вызов после конструктора 
            с 2 параметрами. Таким образом, когда конструктор с 2 параметрами будет вызван, например, var obj = new Obj("Объект", "Нет описания");, 
            сначала отработает конструктор без параметров и выведет в консоль сообщение, а только после этого полю name будет присвоено значение.

            Таким образом, мы использовали функционал конструктора в другом конструкторе.


            Задание 7.1.6
            Реализуйте конструктор, заполняющий поля для следующего класса:

class Obj
{
	private string name;
	private string owner;
	private int length;
	private int count;

	public Obj(string name, string ownerName, int objLength, int count)
	{
		// ...
	}
}

                public Obj(string name, string ownerName, int objLength, int count) 
                {
                    this.name = name;
                    owner = ownerName;
                    length = objLength;
                    this.count = count;
                }

            Задание 7.1.7 
            Впишите пропущенный код для параметров в Console.WriteLine вместо ??? так, чтобы в консоли выводилось "Привет, Грег, я интеллектуальный помощник Олег":

class SmartHelper 
{
  private string name;

  public SmartHelper(string name) 
  {
    this.name = name;
  }

  public void Greetings(string name) 
  {
    Console.WriteLine("Привет, {0}, я интеллектуальный помощник {1}", ???);
  }
}
class Program 
{
  static void Main(string[] args) 
  {
    SmartHelper helper = new SmartHelper("Олег");
    helper.Greetings("Грег");

    Console.ReadKey();
  }

}

            Чтобы в консоли выводилось "Привет, Грег, я интеллектуальный помощник Олег", нужно передать параметры в метод Console.WriteLine в правильном порядке. 
            В данном случае, первый параметр {0} будет заменен на значение переменной name, переданной в метод Greetings, а второй параметр {1} будет заменен на 
            значение поля name объекта SmartHelper.

                 name, this.name

            Кроме this существует и ключевое слово base. С его помощью мы можем обратиться к базовому классу, в частности к его конструкторам:

class BaseClass
{
	public string Name;
	protected string Description;
	private int value;

	public BaseClass(int value)
	{
		this.value = value;
	}
}

class InheritedClass : BaseClass
{
	private int newValue;

	public InheritedClass(int newValue) : base(100)
	{
		this.newValue = newValue;
	}
}

            В конструкторе класса InheritedClass мы обратились к конструктору базового класса, указав значение параметра value, равное 100. 
            Таким образом, аналогично вызову других конструкторов внутри класса, базовый конструктор выполнится до того, как начнет выполнение 
            код внутри конструктора наследника.

            Конструкторы не передаются производному классу при наследовании. Если в базовом классе не определен конструктор по умолчанию без параметров, 
            а только конструкторы с параметрами, то в производном классе мы обязательно должны вызвать один из этих конструкторов через ключевое слово base. 
            Так, если мы уберем конструктор из InheritedClass:

class InheritedClass : BaseClass
{
	private int newValue;
}

            То мы получим ошибку:

            Задание 7.1.8
            Выберите верные ответы. Ключевое слово this позволяет:

                Обращаться к закрытым переменным экземпляра класса-родителя
                Обращаться к закрытым переменным экземпляра данного класса      X
                Обращаться к методам класса-родителя
                Обращаться к конструктору данного класса из конструктора        X
                Обращаться к конструктору класса-родителя из конструктора

            Задание 7.1.9
            Выберите верные ответы. Ключевое слово base позволяет:

                Обращаться к закрытым переменным экземпляра класса-родителя
                Обращаться к закрытым переменным экземпляра данного класса      
                Обращаться к методам класса-родителя                            X
                Обращаться к конструктору данного класса из конструктора        
                Обращаться к конструктору класса-родителя из конструктора       X

            Для класса DerivedClass создайте 2 конструктора: один, принимающий 2 параметра — name и description, второй — принимающий 3 параметра name, description и counter.


class BaseClass 
{
  protected string Name;

  public BaseClass(string name) 
  {
    Name = name;
  }
}

class DerivedClass: BaseClass 
{
  public string Description;

  public int Counter;
}

                        public DerivedClass(string name, string description) : base(name) 
                        {
                            Description = description;
                        }

                        public DerivedClass(string name, string description, int counter) : base(name) 
                        {
                            Description = description;
                            Counter = counter;
                        }

            --------------------------------------
            Преобразование типов
            --------------------------------------

            Ранее мы уже говорили о преобразовании типов для примитивных типов. Теперь рассмотрим преобразования типов над классами.

            Рассмотрим схему наследования для HybridCar: HybrydCar -> Car -> Object

            Благодаря отношению is-a экземпляр HybridCar может быть использован как экземпляр типа Car, а тот в свою очередь — как экземпляр Object.
            
            Таким образом реализуются восходящие преобразования (Upcast). Гибридный автомобиль является автомобилем и может использоваться как обычный автомобиль, 
            без надобности уточнения его топлива.

            Рассмотрим следующую схему классов, в которой будет больше элементов:

            В данной схеме мы используем классы Human и Animal , которые оба унаследованы от Creature (поскольку и человек и животное — существа, все верно). 
            Также у нас имеется класс HomoSapiens (человек разумный) как наследник класса Human.

            Таким образом, над этими классами мы можем производить как явные, так и неявные восходящие преобразования:

class Creature { }

class Animal : Creature { }

class Human : Creature { }

class HomoSapiens : Human { }

class Program
{
	static void Main(string[] args)
	{
		HomoSapiens hs = new HomoSapiens();
		Human human = hs;
		Creature creature = (Creature)human;
		Creature secondCreature = new Animal();

            В данном случае переменной human, которая представляет тип Human, присваивается ссылка на объект HomoSapiens. Таким образом автоматически 
            выполняется неявное восходящее преобразование — преобразование к типу, который находится вверху иерархии классов, то есть к базовому классу.

            В итоге переменные hs и human будут указывать на один и тот же объект в памяти, но переменной human будет доступна только та часть, которая 
            представляет функционал типа Human.

            При преобразовании уже переменной human в тип Creature используется явное преобразование, но принцип работы остается таким же.

            Помимо восходящих преобразований есть и обратные им — нисходящие преобразования (Downcast) от базового типа к производному. Например, 
            когда вы храните экземпляр производного типа в переменной базового типа. Чтобы использовать какой-то метод или поле, не отраженное 
            в базовом классе, вы можете произвести нисходящее преобразование и получить ссылку на экземпляр производного типа:


                Creature secondCreature = new Animal();
                //...
                Animal animal = (Animal)secondCreature;

            Данное преобразование не может быть неявным, поскольку это вызовет ошибку на этапе компиляции:

            Мы можем указать явное преобразование, тогда следующий код будет работать верно:

                object obj = new Animal();
                Animal animal = (Animal)obj;

            Но компилятор не может проверить, какой тип будет находиться в obj, и преобразование может пройти некорректно. Например, если в переменной obj 
            будет не экземпляр типа Animal, а экземпляр object:

                object obj = new object();
                Animal animal = (Animal)obj;

            Компилятор не увидит в этом ошибки. Но преобразовать такой тип у программы не получится — происходит ошибка во время исполнения программы.
            О том, как работать с исключениями, вы узнаете чуть позже. Сейчас поговорим о том, как избегать таких ситуаций.

            Для проверки возможности преобразования используется ключевое слово is:

                if (secondCreature is Animal)
                {
	                Console.WriteLine("Экземпляр имеет тип Animal");
                }

            Важно отметить, что is выдает значение true не только при проверке на оригинальный тип экземпляра объекта (например, secondCreature 
            создавался конструктором типа Animal), но и на все унаследованные типы.

                bool expression;
                expression = secondCreature is Animal;	//true
                expression = secondCreature is Creature;	//true
                expression = secondCreature is object;	//true
                expression = secondCreature is Human;	//false

            Это значит, что для всех возможных преобразований будет возвращено значение true.

            Тогда, чтобы воспользоваться переменной приведенного типа, нужно произвести проверку и только потом преобразование:

                Creature secondCreature = new Animal();
			
                //...
			
                if (secondCreature is Animal)
                {
	                Animal animal = (Animal)secondCreature;
                }

            Но такой способ не очень хорош, поскольку при попытке преобразования secondCreature к типу Animal произойдет ещё одна проверка типа, 
            что обусловлено внутренней работой .Net при преобразовании типов. Для таких случаев в C# существует оператор as:

                    Animal animal = secondCreature as Animal;

            Таким образом, за одну проверку типа объекта C# решает, приводить ли объект к указанному типу, или вернуть значение null. Получается, 
            что для полноценного использования нужно добавить проверку на null, иначе можно получить NullReferenceException

                    Animal animal = secondCreature as Animal;

                    if (animal != null)
                    {
	                // Использование значения animal
                    }

            И вроде бы всё прекрасно. У нас есть is и as для своих целей. Но все равно, некоторые проблемы остаются:

            Приходится делать проверку на null и нагромождать код.

                Значимые типы не могут принимать значение null, поэтому остается только вариант с оператором is и явным преобразованием типа
                Язык C# постоянно развивается, а разработчики прислушиваются к пользователям. Благодаря этому в версии языка 7.0 появилось так называемое
                «Сопоставление шаблонов» (Pattern Matching) для оператора is:

                    if (secondCreature is Animal animal)
                    {
	                // Использование значения animal
                    }

            После указания типа для оператора is добавилось наименование переменной. Таким образом, если тип соответствует Animal, то в области видимости
            выражения if будет доступна переменная animal типа Animal. И все это оптимизировано и выглядит просто. А самое интересное, что данный способ 
            прекрасно работает со структурами, поскольку значения null просто не нужно использовать.

            Данный способ является рекомендуемым для использования (если версия языка вам это позволяет).

            Задание 7.1.11 
            Выберите тот вариант кода, в котором будет выведено сообщение в консоль:

object obj = new Animal();

if (obj as Animal) 
{
  Console.WriteLine("Объект класса Animal");
}

object obj = new object();

if (obj is Animal) 
{
  Console.WriteLine("Объект класса Animal");
}

object obj = new Animal();

if (obj is Animal) 
{
  Console.WriteLine("Объект класса Animal");
}

Animal obj = new object();

if (obj is Animal) 
{
  Console.WriteLine("Объект класса Animal");
}

            Ответ:

                object obj = new Animal();

                if (obj is Animal) 
                {
                    Console.WriteLine("Объект класса Animal");
                }

            */

        }
    }
}
